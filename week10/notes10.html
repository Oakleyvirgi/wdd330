<!doctype html>
<html lang="en-us">

<head>
    <title>Week 10 | Notes</title>
    <meta charset="utf-8">
    <meta name="viewpoint" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="Assignment portal for Brother Jason Blazzard in WDD 330: Web Frontend Development II at Brigham Young University - Idaho">
    <link rel="stylesheet" href="/css/main.css">


</head>

<body>
    <header>
        <h1>Week 10 - Notes</h1>

    </header>
    <main>
        <h4>pattern</h4>
        <p>Specifies a regular expression that defines a pattern the entered data needs to follow. <br>
        </p>
        <h4>willValidate</h4>
        <p>Returns true if the element will be validated when the form is submitted; false otherwise.</p>
        <h4>checkValidity()</h4>
        <p>Returns true if the element's value has no validity problems; false otherwise. If the element is invalid,
            this method also fires an invalid event on the element.</p>
        <h4>setCustomValidity(message)</h4>
        <p>Adds a custom error message to the element; if you set a custom error message, the element is considered to
            be invalid, and the specified error is displayed. This lets you use JavaScript code to establish a
            validation failure other than those offered by the standard HTML5 validation constraints. The message is
            shown to the user when reporting the problem.</p>
        <h4>validity.typeMismatch</h4>
        <p>Returns true, meaning that the contained value doesn't match the pattern for a well-formed email address. If
            so, we call the setCustomValidity() method with a custom message. This renders the input invalid, so that
            when you try to submit the form, submission fails and the custom error message is displayed.</p>
        <h4>Request()</h4>
        <p>accepts exactly the same parameters as the fetch() method. You can even pass in an existing request object to
            create a copy of it:</br>

            const anotherRequest = new Request(myRequest, myInit);
        </p>
        <h4>clone()</h4>
        <p>Creates a copy. Both methods of creating a copy will fail if the body of the original request or response has
            already been read, but reading the body of a cloned response or request will not cause it to be marked as
            read in the original.
        </p>
        <h4>Headers</h4>
        <p>allows you to create your own headers object via the Headers() constructor. A headers object is a simple
            multi-map of names to values:<br>

            const content = 'Hello World';<br>
            const myHeaders = new Headers();<br>
            myHeaders.append('Content-Type', 'text/plain');<br>
            myHeaders.append('Content-Length', content.length.toString());<br>
            myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');<br>
        </p>
        <h4>Response.status</h4>
        <p>An integer (default value 200) containing the response status code.</p>
        <h4>Response.statusText</h4>
        <p>A string (default value ""), which corresponds to the HTTP status code message. Note that HTTP/2 does not
            support status messages.</p>
        <h4>availHeight and availWidth</h4>
        <p>The availHeight and availWidth can be used to find the height and width of the screen,
        </p>
        <h4>Response.ok</h4>
        <p>Seen in use above, this is a shorthand for checking that status is in the range 200-299 inclusive. This returns a Boolean.</p>
    </main>
    <footer>
        <p>&copy;2021 | Virgithmar Oakley | North Carolina |<a href="https://www.byui.edu/online">BYU-I Online
                Learning</a><br>
    </footer>
</body>

</html>